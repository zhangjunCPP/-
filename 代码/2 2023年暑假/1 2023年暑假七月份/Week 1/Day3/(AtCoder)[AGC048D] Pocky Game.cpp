/*
 记先手为A，后手为B
 容易想到：A想要左侧的尽量大，B想要右侧的尽量大
 那么，易得：
    要么取一个，要么取一堆
    如果在一堆中取了多个，这一堆剩下的肯定没有只取一个的多
    如果这一堆的后面一堆比该堆多，那么取完一整堆肯定最优
 也就是说，游戏流程大概是这样的：
    双方先一堆一堆的取，取到下一堆不如本堆时，开始一个一个地取，然后又一堆一堆的取……
 那么，在双方打拉锯战时，必定有一个人会因为棋子不够多导致失败
 所以，我们可以这样做：
    定义数组a表示一开始的石子数，b表示游戏进行到某时的石子数。
    定义dp数组L[i][j]表示：b[i+1]=a[i+1],b[i+2]=a[i+2],……,b[j]=a[j]且轮到先手时，b[i]至少为多少才能让先手赢
             R[i][j]表示：b[i]=a[i],b[i+1]=a[i+1],……,b[j-1]=a[j-1]且轮到后手时，b[j]至少为多少才能让后手赢
    考虑L[i][j]如何转移:
        (1)如果此时先手第i堆取完了就获胜，即R[i+1][j]>a[j](b[j])，发现，这种情况与b[i]无关，所以b[i]最小为1  ----> L[i][j]=1
        (2)如果此时先手不能直接取一堆，那么双方就会陷入拉锯战，一个一个的取。考虑后手，他不断的取，终有个时候b[j]<R[i+1][j]，此时，先手去完一整堆，后手输
           所以，先手要和后手拉锯(a[j]-R[i+1][j]+1)次  ---->L[i][j]=L[i][j-1]+(a[j]-R[i+1][j]+1)
    对于R[i][j]同理
    初始值：L[i][i]=R[i][i]=1

 */
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[10000000];
int L[105][105],R[105][105];
signed main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++) L[i][i]=R[i][i]=1;
        for(int i=n-1;i>=1;i--){
            for(int j=i+1;j<=n;j++){
                if(R[i+1][j]>a[j]) L[i][j]=1;
                else L[i][j]=L[i][j-1]+(a[j]-R[i+1][j]+1);
                if(L[i][j-1]>a[i]) R[i][j]=1;
                else R[i][j]=R[i+1][j]+(a[i]-L[i][j-1]+1);
            }
        }
        if(L[1][n]<=a[1]) puts("First");
        else puts("Second");
    }
}